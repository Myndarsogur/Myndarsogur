<!DOCTYPE html>
<html lang="is">
<head>
  <meta charset="UTF-8">
  <title>Litað Tau</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #f0f0f0;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="tauCanvas"></canvas>

<script>
  const canvas = document.getElementById("tauCanvas");
  const ctx = canvas.getContext("2d");

  function stillaStærð() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  stillaStærð();
  window.addEventListener("resize", stillaStærð);

  const points = [];
  const cols = 30; // aðeins minna til að byrja með
  const rows = 20;
  const spacing = 25;

  const originX = canvas.width / 2 - cols * spacing / 2;
  const originY = 50;  // byrjum ofar!

  class Point {
    constructor(x, y, fixed = false) {
      this.x = x;
      this.y = y;
      this.oldx = x;
      this.oldy = y;
      this.fixed = fixed;
    }

    update() {
      if (this.fixed) return;
      let vx = (this.x - this.oldx) * 0.98;
      let vy = (this.y - this.oldy) * 0.98 + 0.2;
      this.oldx = this.x;
      this.oldy = this.y;
      this.x += vx;
      this.y += vy;
    }

    constrain() {
      const bounce = 0.8;
      if (this.x > canvas.width) {
        this.x = canvas.width;
        this.oldx = this.x + (this.x - this.oldx) * bounce;
      }
      if (this.x < 0) {
        this.x = 0;
        this.oldx = this.x + (this.x - this.oldx) * bounce;
      }
      if (this.y > canvas.height) {
        this.y = canvas.height;
        this.oldy = this.y + (this.y - this.oldy) * bounce;
      }
      if (this.y < 0) {
        this.y = 0;
        this.oldy = this.y + (this.y - this.oldy) * bounce;
      }
    }
  }

  class Stick {
    constructor(p1, p2, col, row) {
      this.p1 = p1;
      this.p2 = p2;
      this.length = spacing;
      this.color = `hsl(${(col + row * cols) % 360}, 60%, 40%)`;
    }

    update() {
      const dx = this.p2.x - this.p1.x;
      const dy = this.p2.y - this.p1.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const diff = this.length - dist;
      const percent = diff / dist / 2;
      const offsetX = dx * percent;
      const offsetY = dy * percent;

      if (!this.p1.fixed) {
        this.p1.x -= offsetX;
        this.p1.y -= offsetY;
      }
      if (!this.p2.fixed) {
        this.p2.x += offsetX;
        this.p2.y += offsetY;
      }
    }

    draw(ctx) {
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(this.p1.x, this.p1.y);
      ctx.lineTo(this.p2.x, this.p2.y);
      ctx.stroke();
    }
  }

  const sticks = [];
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const fixed = y === 0 && x % 4 === 0;
      const p = new Point(originX + x * spacing, originY + y * spacing, fixed);
      points.push(p);

      if (x > 0) {
        sticks.push(new Stick(p, points[points.length - 2], x, y));
      }
      if (y > 0) {
        sticks.push(new Stick(p, points[(y - 1) * cols + x], x, y));
      }
    }
  }

  let dragPoint = null;
  canvas.addEventListener("mousedown", e => {
    const mx = e.clientX;
    const my = e.clientY;
    dragPoint = points.find(p => {
      const dx = p.x - mx;
      const dy = p.y - my;
      return dx * dx + dy * dy < 400;
    });
  });
  canvas.addEventListener("mouseup", () => dragPoint = null);
  canvas.addEventListener("mousemove", e => {
    if (dragPoint && !dragPoint.fixed) {
      dragPoint.x = e.clientX;
      dragPoint.y = e.clientY;
    }
  });

  canvas.addEventListener("touchstart", e => {
    const touch = e.touches[0];
    const mx = touch.clientX;
    const my = touch.clientY;
    dragPoint = points.find(p => {
      const dx = p.x - mx;
      const dy = p.y - my;
      return dx * dx + dy * dy < 400;
    });
  });
  canvas.addEventListener("touchend", () => dragPoint = null);
  canvas.addEventListener("touchmove", e => {
    if (dragPoint && !dragPoint.fixed) {
      const touch = e.touches[0];
      dragPoint.x = touch.clientX;
      dragPoint.y = touch.clientY;
    }
  });

  function animate() {
    for (let i = 0; i < 10; i++) {
      sticks.forEach(s => s.update());
      points.forEach(p => p.update());
    }
    points.forEach(p => p.constrain());

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    sticks.forEach(s => s.draw(ctx));

    requestAnimationFrame(animate);
  }

  animate();
</script>
</body>
</html>