<style>
    :root { --anim-ms: 280ms; }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      color: #fff;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
      overscroll-behavior: contain;
    }
    #viewer {
      position: fixed;
      inset: 0;
      /* tryggjum 100% h√¶√∞ √° mismunandi v√∂frum */
      height: 100dvh;
      height: 100svh;
      height: 100vh;
      padding: env(safe-area-inset-top) env(safe-area-inset-right)
               env(safe-area-inset-bottom) env(safe-area-inset-left);
      background: #000;
      overflow: hidden;
      display: grid;
      place-items: center;
      touch-action: none;
    }
    .layer {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      will-change: transform, opacity;
      contain: paint;
      pointer-events: none;
      transform: translate3d(0,0,0);
    }
    .page {
      max-width: 100%;
      max-height: 100%;
      width: 100%;
      height: 100%;
      object-fit: contain;         /* tryggir a√∞ myndin sj√°ist */
      object-position: center;     /* mi√∞ju√∞ */
      backface-visibility: hidden;
      transform: translate3d(0,0,0) scale(1);
      will-change: transform;
      -webkit-user-drag: none;
      pointer-events: none;
    }
  
    .slide-in-next   { transform: translateX(100%); }
    .slide-in-prev   { transform: translateX(-100%); }
    .slide-in-active { transition: transform var(--anim-ms) ease; transform: translateX(0%); }
    .slide-out-active-next { transition: transform var(--anim-ms) ease, opacity var(--anim-ms) ease; transform: translateX(-30%); opacity: .6; }
    .slide-out-active-prev { transition: transform var(--anim-ms) ease, opacity var(--anim-ms) ease; transform: translateX(30%);  opacity: .6; }
  
    @media (prefers-reduced-motion: reduce) { :root { --anim-ms: 0ms; } }
  
    .sr-only {
      position: absolute !important;
      width: 1px; height: 1px;
      padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,1px,1px); white-space: nowrap; border: 0;
    }
    /* F√≠n villukort ef ekkert fannst */
    .error {
      font: 500 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #bbb;
      text-align: center;
      padding: 24px;
    }
    .error b { color: #fff; }
  </style>
  
  <script>
    /* ====== STILLINGAR ====== */
    const TOTAL_PAGES = 24;
    const BASE_DIR = 'pages';    // mappan vi√∞ hli√∞ina √° index.html (EKKI me√∞ fremri sk√°strik)
  
    /* B√∫um til lista af l√≠klegum skr√°arn√∂fnum fyrir s√≠√∞u i */
    function candidatePaths(i) {
      const pad3 = String(i).padStart(3,'0');   // 001
      const raw  = String(i);                   // 1
      const exts = ['avif','webp','jpg','jpeg','png'];
  
      const rels = [
        `${BASE_DIR}/${pad3}`, `${BASE_DIR}/${raw}`,
        `./${BASE_DIR}/${pad3}`, `./${BASE_DIR}/${raw}`,
      ];
  
      const out = [];
      for (const stem of rels) for (const ext of exts) out.push(`${stem}.${ext}`);
      return out;
    }
  
    const viewer  = document.getElementById('viewer');
    const layerA  = document.getElementById('layerA');
    const layerB  = document.getElementById('layerB');
    const status  = document.getElementById('status');
  
    let currentLayer = layerA, backLayer = layerB;
    let pageIndex = 1;
    let imgEl = null;
  
    /* zoom/pan breytur (√≥breyttar fr√° fyrri √∫tg√°fu) */
    const pointers = new Map();
    let startMid = null, startDist = 0, startScale = 1, startTx = 0, startTy = 0;
    let scale = 1, tx = 0, ty = 0;
    let oneStart = null;
    let rafPending = false;
  
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    function setTransform(){ if(!imgEl) return; imgEl.style.transform=`translate3d(${tx}px, ${ty}px, 0px) scale(${scale})`; }
    function scheduleDraw(){ if(rafPending) return; rafPending=true; requestAnimationFrame(()=>{ setTransform(); rafPending=false; }); }
    function resetTransform(animate=false){ scale=1; tx=0; ty=0; if(!imgEl) return; imgEl.style.transition=animate?'transform 180ms ease':'none'; setTransform(); if(animate) imgEl.addEventListener('transitionend',()=>{imgEl.style.transition='none';},{once:true}); }
    function containerSize(){ const r = viewer.getBoundingClientRect(); return {w:r.width,h:r.height}; }
    function clampPan(){ const {w,h}=containerSize(); const maxX=(w*(scale-1))/2; const maxY=(h*(scale-1))/2; tx=clamp(tx,-maxX,maxX); ty=clamp(ty,-maxY,maxY); }
    function announce(msg){ status.textContent = msg; }
  
    /* Reynir a√∞ hla√∞a fyrstu virku sl√≥√∞inni √∫r candidates[] */
    function loadBestImage(index, candidates, onload, onfail){
      const layer = document.createElement('div'); // nota√∞ t√≠mabundi√∞
      let k = 0;
      function tryNext(){
        if (k >= candidates.length) { onfail && onfail(); return; }
        const src = candidates[k++];
        const im = new Image();
        im.decoding = 'async';
        im.loading = 'eager';
        im.alt = `S√≠√∞a ${index} af ${TOTAL_PAGES}`;
        im.className = 'page';
        im.src = src;
        im.onload = ()=> onload && onload(im, src);
        im.onerror = ()=> tryNext(); // pr√≥fa n√¶stu sl√≥√∞
        layer.replaceChildren(im); // halda eina til a√∞ losa minni√∞
      }
      tryNext();
    }
  
    function renderError(layer, index){
      const card = document.createElement('div');
      card.className = 'error';
      card.innerHTML = `
        ü§∑‚Äç‚ôÇÔ∏è Gat ekki fundi√∞ <b>s√≠√∞u ${index}</b>.<br>
        Pr√≥fa√∞i margar skr√°r (AVIF/WebP/JPG/PNG).<br><br>
        Athuga√∞u:<br>
        ‚Ä¢ Er mappan <b>${BASE_DIR}/</b> til?<br>
        ‚Ä¢ Heitir skr√°in <b>${String(index).padStart(3,'0')}.jpg</b> e√∞a samb√¶rilegt?<br>
        ‚Ä¢ Er h√°/l√°g stafsetning r√©tt (t.d. .JPG vs .jpg)?<br>
        ‚Ä¢ Er vefurinn keyr√∞ur yfir <b>http(s)</b> frekar en file:// √° iOS?
      `;
      layer.replaceChildren(card);
    }
  
    function loadInto(layer, index, done){
      layer.innerHTML = '';
      const candidates = candidatePaths(index);
      loadBestImage(index, candidates, (img, src)=>{
        layer.replaceChildren(img);
        done && done(img, src);
      }, ()=>{
        renderError(layer, index);
        done && done(null, null);
      });
    }
  
    function preloadNeighbors(i){
      const next = i+1<=TOTAL_PAGES ? candidatePaths(i+1)[0] : null;
      const prev = i-1>=1 ? candidatePaths(i-1)[0] : null;
      [next, prev].filter(Boolean).forEach(src => { const im=new Image(); im.src=src; });
    }
  
    function showPage(index, direction=null){
      index = clamp(index, 1, TOTAL_PAGES);
      if (index === pageIndex && !direction) return;
  
      const oldLayer = currentLayer;
      const newLayer = backLayer;
      newLayer.hidden = false;
  
      loadInto(newLayer, index, (newImg, usedSrc)=>{
        imgEl = newImg; // getur veri√∞ null ef allt br√°st
        resetTransform(false);
  
        const enterClass = direction==='next' ? 'slide-in-next' : direction==='prev' ? 'slide-in-prev' : '';
        const exitActive = direction==='next' ? 'slide-out-active-next' : direction==='prev' ? 'slide-out-active-prev' : '';
  
        if (direction) {
          newLayer.classList.add(enterClass);
          newLayer.getBoundingClientRect(); // reflow
          newLayer.classList.add('slide-in-active');
          oldLayer.classList.add(direction==='next' ? 'slide-out-next' : 'slide-out-prev', exitActive);
        }
  
        const finalize = ()=>{
          oldLayer.className = 'layer';
          newLayer.className = 'layer';
          oldLayer.hidden = true;
          [currentLayer, backLayer] = [newLayer, oldLayer];
          pageIndex = index;
          announce(`S√≠√∞a ${pageIndex} af ${TOTAL_PAGES}${usedSrc?` ‚Äì ${usedSrc}`:''}`);
          preloadNeighbors(pageIndex);
        };
  
        if (direction) {
          const onEnd = (ev)=>{ if (ev.target!==newLayer) return; newLayer.removeEventListener('transitionend', onEnd); finalize(); };
          newLayer.addEventListener('transitionend', onEnd);
        } else {
          finalize();
        }
      });
    }
  
    // Byrja √° s√≠√∞u 1
    showPage(pageIndex);
  
    /* ====== GESTURES (√≥breytt a√∞ mestu) ====== */
    viewer.addEventListener('pointerdown', (e) => {
      viewer.setPointerCapture(e.pointerId);
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (pointers.size === 1) oneStart = { x: e.clientX, y: e.clientY, t: performance.now() };
      if (pointers.size === 2) {
        const pts = Array.from(pointers.values());
        startDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
        startMid  = { x: (pts[0].x + pts[1].x) / 2, y: (pts[1].y + pts[0].y) / 2 }; // mi√∞ja
        startScale = scale; startTx = tx; startTy = ty;
      }
    }, { passive: true });
  
    viewer.addEventListener('pointermove', (e) => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
  
      if (pointers.size === 2) {
        e.preventDefault();
        const pts = Array.from(pointers.values());
        const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
        if (startDist > 0) {
          const raw = startScale * (dist / startDist);
          const newScale = clamp(raw, 1, 4);
          const cx = startMid.x, cy = startMid.y;
          const contentX = (cx - startTx) / startScale;
          const contentY = (cy - startTy) / startScale;
          scale = newScale;
          tx = cx - contentX * scale;
          ty = cy - contentY * scale;
          clampPan(); scheduleDraw();
        }
        return;
      }
  
      if (pointers.size === 1 && scale > 1.01) {
        e.preventDefault();
        const p = pointers.get(e.pointerId);
        const dx = p.x - oneStart.x;
        const dy = p.y - oneStart.y;
        tx = startTx + dx;
        ty = startTy + dy;
        clampPan(); scheduleDraw();
      }
    }, { passive: false });
  
    function clearPointer(e){
      if (!pointers.has(e.pointerId)) return;
      pointers.delete(e.pointerId);
      if (pointers.size < 2) { startDist = 0; startMid = null; startScale = scale; startTx = tx; startTy = ty; }
      if (pointers.size === 0 && oneStart) {
        const dx = e.clientX - oneStart.x;
        const dy = e.clientY - oneStart.y;
        const dt = performance.now() - oneStart.t;
        oneStart = null;
        if (scale <= 1.03) {
          const horiz = Math.abs(dx) > 60 && Math.abs(dy) < 80;
          const quick = dt < 500;
          if (horiz && quick) {
            if (dx < 0 && pageIndex < TOTAL_PAGES)      showPage(pageIndex + 1, 'next');
            else if (dx > 0 && pageIndex > 1)           showPage(pageIndex - 1, 'prev');
          }
        } else { clampPan(); scheduleDraw(); }
      }
    }
    ['pointerup','pointercancel','pointerleave'].forEach(t=>viewer.addEventListener(t, clearPointer, { passive:true }));
  
    // double-tap zoom
    let lastTap = 0;
    viewer.addEventListener('pointerdown', (e) => {
      const now = performance.now();
      if (now - lastTap < 280 && pointers.size === 1) {
        if (scale > 1.01) resetTransform(true);
        else {
          const targetScale = 2;
          const cx = e.clientX, cy = e.clientY;
          const contentX = (cx - tx) / scale;
          const contentY = (cy - ty) / scale;
          scale = targetScale;
          tx = cx - contentX * scale;
          ty = cy - contentY * scale;
          clampPan();
          imgEl && (imgEl.style.transition = 'transform 180ms ease');
          setTransform();
          imgEl && imgEl.addEventListener('transitionend', ()=>{ imgEl.style.transition='none'; }, { once:true });
        }
      }
      lastTap = now;
    }, { passive: true });
  
    window.addEventListener('keydown', (e) => {
      if ((e.key==='ArrowRight'||e.key==='PageDown') && pageIndex<TOTAL_PAGES && scale<=1.03) showPage(pageIndex+1,'next');
      else if ((e.key==='ArrowLeft'||e.key==='PageUp') && pageIndex>1 && scale<=1.03) showPage(pageIndex-1,'prev');
      else if (e.key==='Escape') resetTransform(true);
    });
  
    document.addEventListener('gesturestart', (e) => e.preventDefault());
    viewer.addEventListener('pointerdown', () => { if (scale>1.01){ startTx=tx; startTy=ty; } }, { passive:true });
  
    announce(`S√≠√∞a ${pageIndex} af ${TOTAL_PAGES}`);
  </script>